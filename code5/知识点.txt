1.信号量与信号无关 信号是发给进程的用来进行事件异步通知的机制
异步：两者毫不相干，信号的产生与进程的运行毫不相干
前台进程和后台进程：
前台进程可以在stdin中读取数据并做出处理 后台不行但是二者都可以向显示屏文件打印
命令行：fg 任务号 （将对应的任务放到前台） bg（放后台）
jobs查看所有的后台任务 ctrl+z暂停任务，前台任务不能被暂停所以把前台任务放到后台要把bash放到前台接受用户的指令
2.结论：进程在还没收到信号时就知道了信号来了该怎么做（handle pending block三个表之中保存了信号的识别和处理方式）
        信号的处理不是立刻的而是在合适的时候（由内核态返回用户态时会进行信号检查和信号捕捉）
        信号源很多
        （1）键盘：ctrl+c/z... | （2）命令行kill -？pid 
        （3）系统调用：kill（）[向特定进程发送信号] raise（）[自己向自己发送信号] 
        abort（）[自己给自己发送信号6 并去除6号的自定义方法捕捉]
        pause（）[让进程一直等待信号]其实是os的本质
        （4）软中断：pipe管道文件读端关闭 写端强制关闭
        （5）硬中断：异常cpu寄存器标志位出错向中断控制器发送中断 然后再向cpu发送信号
        cpu接受信号并将中断号传递给os并发送中断 os再查询中断服务表 处理中断

3.自定义方法捕捉：signal（int signum，void XX（int））9号和19号无法被自定义捕捉
4.闹钟alarm() 定义一个闹钟时间到就发送终止信号（14号）在进程pcb中放入闹钟时间到就切换进程（自定义14号信号的捕捉方法）
5.信号的保存：
信号的处理不是立刻的而是在合适的时候所以要对信号进行保存（由内核态返回用户态时会进行信号检查和信号捕捉）
信号处理叫做（信号递达），从传递到处理过程叫做信号未决
进程可以通过block表对信号进行未决 让信号一直处于阻塞状态 但是阻塞和忽略是两种不一样的东西前者是信号的状态，后者是信号的处理方式
6.3表
block表：
阻塞表：表示哪些信号会被阻塞即不能被递达一直处于未决状态 
sigaddset(),sigempty(),sigpromask()
修改表     ,表置空     , 类似于umask屏蔽要修改promask才能对block表彻底更改
promask的参数1. 标志位：SIG_BLOCK,SIG_UNBLOCK,SIG_SETMASK(常用用我创建的表来替换)2.我创建的表3.set_t*oldset(旧表传递)
pending表：
未决表：表示哪些信号没有被递达
9，19不能被阻塞和自定义捕捉
pending表在信号递达之前就清零了
当普通信号产生多次时Linux中只算一次
handle表：
处理表：类似与函数指针数组包含了各个信号的处理方法0，1通过宏替换表示忽略和默认的处理方法
信号处理的默认行为一般为退出终止当分为两种类型
core：会在当前路径下形成一个文件保留该进程的核心数据（核心转储）
term：直接退出
在进程退出码的低8位为退出码 下一位为是否是coredump退出（核心转储）

信号捕抓：
1.合适的时候：进程从内核态返回用户态时会进行信号检查
2.信号捕捉在执行用户方法时os必须进行频繁的身份切换防止用户程序进行非法操作，进程因为会被调度从此进入内核态
3.捕捉过程：1.用户代码有异常,陷阱，硬件中断陷入内核 2.通过对应的中断服务处理这些异常 3.进行信号检查
4.如果有进行信号处理方法默认或者自定义其中os会对正在处理的信号的block表置1 5.处理完毕回到用户态从程序上次中断的地方进行运行
硬件中断：1.硬件准备就绪发送中端2.中断控制器向cpu发送中断并填写中断号并通知cpu3.cpu接受中断4.cpu通过中断向量表查询对应的中断服务
信号与硬件中断相似都是发送->保存->查询->处理中断也可以被屏蔽
时间源：cpu内部以特定频率向cpu发送特定中断进行进程调度，进程切换... , 时间片：因为时间源频率固定所以每次发送中断count--为0进行调度
os是一个基于中断运行的代码块有什么需要往中断向量表中添加对应的服务
在cpu中的软件中断方法为int/syscall这些叫做陷阱
系统调用的本质就是将系统调用号+int/syscall，os将所有的系统调用方法放入中断向量表中加上下标，cpu触发软中断后查询向量表进行相应的处理
所以内核态和用户态就是cpu执行不同的代码和数据，在进程的虚拟地址空间进行不断的跳转

本章我对进程的一生粗浅的理解
1.程序经过预处理->编译->汇编->链接运行创建各种内核数据结构，并且构建虚拟内存空间
2.将对应进程的代码和数据从磁盘中加载到内存，根据ELF文件的表头查看各个segment的范围和信息以及最重要的entry address
构建struct file 产生dentry树
3.将各种segment的平坦编址转移到进程的虚拟地址空间填写页表在需要使用时触发缺页中断完善页表
如果是动态链接在数据段中的got表会进行地址重定位，并将动态库加载到共享区
4.进程时间片到了会被进程切换在被切换时其cpu的上下文数据会被保存在task_struct中并将该进程放入empire_queue中进行排队 
在下一次进程调度时会将这些上下文数据加载到寄存器中继续运行，代码和数据被加载到内存中不会被删除
5.在内存空间不足时os会将一下不常用的代码和数据与磁盘中的交换去进行换出

虚拟地址空间[0-4GB]
[0-3]为用户空间可以随意跳转但不能拿着3-4GB的虚拟地址访问内核的代码和数据
[3-4GB]固定为内核空间所以内核页表只有一份不管进程如何调度都能找到内核的代码和数据
在系统中怎么区分现在是user还是kernel状态在cpu的cs寄存器中后2位比特位00：内核，11：用户
所以通过int/syscall来改变标志位从而访问不同区域的代码和数据这就是内核态和用户态的本质

可重入函数：多个执行流访问不会出错（这是函数的特点） 涉及到线程安全
volatile关键字：保证内存的可见性（防止编译器优化导致一个值本应该从内存搬运到寄存器中进行判断而不是直接判断寄存器上的值）导致程序一直判断上一个值
