1.信号量与信号无关 信号是发给进程的用来进行事件异步通知的机制
异步：两者毫不相干，信号的产生与进程的运行毫不相干
前台进程和后台进程：
前台进程可以在stdin中读取数据并做出处理 后台不行但是二者都可以向显示屏文件打印
命令行：fg 任务号 （将对应的任务放到前台） bg（放后台）
jobs查看所有的后台任务 ctrl+z暂停任务，前台任务不能被暂停所以把前台任务放到后台要把bash放到前台接受用户的指令
2.结论：进程在还没收到信号时就知道了信号来了该怎么做（handle pending block三个表之中保存了信号的识别和处理方式）
        信号的处理不是立刻的而是在合适的时候（由内核态返回用户态时会进行信号检查和信号捕捉）
        信号源很多
        （1）键盘：ctrl+c/z... | （2）命令行kill -？pid 
        （3）系统调用：kill（）[向特定进程发送信号] raise（）[自己向自己发送信号] 
        abort（）[自己给自己发送信号6 并去除6号的自定义方法捕捉]
        pause（）[让进程一直等待信号]其实是os的本质
        （4）软中断：pipe管道文件读端关闭 写端强制关闭
        （5）硬中断：异常cpu寄存器标志位出错向中断控制器发送中断 然后再向cpu发送信号
        cpu接受信号并将中断号传递给os并发送中断 os再查询中断服务表 处理中断

3.自定义方法捕捉：signal（int signum，void XX（int））9号和19号无法被自定义捕捉
4.闹钟alarm() 定义一个闹钟时间到就发送终止信号（14号）在进程pcb中放入闹钟时间到就切换进程（自定义14号信号的捕捉方法）
5.信号的保存：
信号的处理不是立刻的而是在合适的时候所以要对信号进行保存（由内核态返回用户态时会进行信号检查和信号捕捉）
信号处理叫做（信号递达），从传递到处理过程叫做信号未决
进程可以通过block表对信号进行未决 让信号一直处于阻塞状态 但是阻塞和忽略是两种不一样的东西前者是信号的状态，后者是信号的处理方式
6.3表
block表：
阻塞表：表示哪些信号会被阻塞即不能被递达一直处于未决状态 
pending表：
未决表：表示哪些信号没有被递达
9，19不能被阻塞和自定义捕捉
handle表：
处理表：类似与函数指针数组包含了各个信号的处理方法0，1通过宏替换表示忽略和默认的处理方法